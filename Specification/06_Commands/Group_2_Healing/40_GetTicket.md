# GET TICKET (Group 2, Code 40)

## Quick Reference

| Property | Value |
|----------|-------|
| Command Group | 2 |
| Command Code | 40 |
| Header Size | 32 bytes |
| Request Body | 18 + (21 * N) bytes |
| Response Body | Tickets (16 * N) + terminator |
| Encryption | Required |
| Transport | UDP preferred |

## Purpose

Obtains healing tickets from trusted RAIDA to fix fractured tokens.
Tickets prove ownership on one RAIDA and can convince other RAIDA.

## When to Use

1. Token passes Detect on some RAIDA but fails on others
2. Need to synchronize AN across all RAIDA
3. Preparing to heal a fractured token

## Request Body

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| 0-15 | 16 | Challenge | 12 random + 4 CRC32 |
| 16+ | 21*N | Tokens | N token records |
| Last 2 | 2 | Terminator | 0x3E 0x3E |

### Token Record (21 bytes each)

| Offset | Size | Field |
|--------|------|-------|
| 0 | 1 | Denomination |
| 1-4 | 4 | Serial Number (BE) |
| 5-20 | 16 | Authenticity Number |

## Response

| Status | Body |
|--------|------|
| 241 (ALL_PASS) | N Ã— 16-byte tickets |
| 242 (ALL_FAIL) | None |
| 243 (MIXED) | Bitfield + valid tickets |

### Ticket Format (16 bytes)

Tickets are opaque blobs generated by RAIDA. They:
- Prove the requestor knew the correct AN
- Are time-limited (typically valid for minutes)
- Are specific to the requesting RAIDA pair

## Algorithm

### Build Request
```pseudocode
function build_get_ticket_request(tokens: list, raida_id: int) -> bytes:
    body_len = 16 + (21 * len(tokens)) + 2
    header = build_header_32(
        raida_id = raida_id,
        command_group = 2,
        command_code = 40,
        encryption_type = 1,
        key_dn = tokens[0].denomination,
        key_sn = tokens[0].serial_number,
        body_length = body_len
    )

    body = generate_challenge()
    for token in tokens:
        body += bytes([token.denomination])
        body += token.serial_number.to_bytes(4, 'big')
        body += token.an[raida_id]

    padded = pad_body(body, encryption_type=1)
    key = tokens[0].an[raida_id]
    encrypted = aes_ctr_encrypt(padded, key, nonce)

    return header + encrypted + b'\x3E\x3E'
```

### Parse Response
```pseudocode
function parse_ticket_response(response: bytes, token_count: int) -> list:
    header = parse_response_header(response)

    if header.status == 241:
        // All tickets present
        body = response[32:-2]
        tickets = []
        for i in range(token_count):
            tickets.append(body[i*16 : (i+1)*16])
        return tickets

    elif header.status == 242:
        return [None] * token_count

    elif header.status == 243:
        // Mixed - parse bitfield first
        bitfield_size = (token_count + 7) // 8
        bitfield = response[32 : 32 + bitfield_size]
        ticket_data = response[32 + bitfield_size : -2]

        tickets = []
        ticket_offset = 0
        for i in range(token_count):
            if bit_is_set(bitfield, i):
                tickets.append(ticket_data[ticket_offset : ticket_offset + 16])
                ticket_offset += 16
            else:
                tickets.append(None)
        return tickets
```

## Healing Workflow

```
Step 1: Detect token on all 25 RAIDA
        Result: RAIDA 0-12 pass, RAIDA 13-24 fail

Step 2: Get tickets from passing RAIDA (0-12)
        Result: 13 valid tickets

Step 3: Send Fix command to failing RAIDA (13-24)
        Include: 13 tickets from step 2
        Result: Failed RAIDA update their AN

Step 4: Detect again to verify healing
        Result: All 25 RAIDA pass
```

## Example

### Request for 1 token
```
Body before encryption:
[16B challenge]
01 00 01 8F 3D [16B AN]  // DN=1, SN=102205
3E 3E
```

### Response (ALL_PASS)
```
Header: ... status=0xF1 (241) ...
Body: [16B ticket] 3E 3E
```

## Common Mistakes

**DON'T** request tickets from failing RAIDA:
```python
# WRONG - These RAIDA don't know the AN
for raida in failing_raida:
    ticket = get_ticket(raida, token)  # Will fail!
```

**DO** request tickets only from passing RAIDA:
```python
# CORRECT
detect_results = detect_all(token)
passing = [i for i, r in enumerate(detect_results) if r]
tickets = [get_ticket(raida, token) for raida in passing]
```

**DON'T** cache tickets for too long:
```python
# WRONG - Tickets expire
tickets = get_tickets_all()
time.sleep(3600)  # Wait an hour
fix_token(tickets)  # Tickets may be expired!
```

**DO** use tickets immediately:
```python
# CORRECT
tickets = get_tickets_from_passing()
fix_failing_raida(tickets)  # Use right away
```
